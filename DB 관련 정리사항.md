# Database

## 단어 및 개념

- 데이터베이스 스키마(schema) : 데이터베이스를 설계, 생성하는 과정에서 각각의 테이블에 필요한 컬럼의 타입과 네이밍을 결정하는 것.

- DBMS : 데이터베이스를 관리하는 시스템

  - 사용자와 DB사이에서 사용자의 요구에 따라 데이터를 생성해주고 DB를 관리해주는 소프트웨어
  - 데이터를 계층 또는 탐색 형식으로 저장. 파일 시스템을 사용해 저장하며 따라서 테이블 간에는 아무런 관계가 없다.
  - 데이터에 대한 많은 보안을 제공하지 않으며, 정규화를 수행할 수 없어 데이터으 높은 중복성을 가질 수 있다.

- RDBMS : 관계형 데이터 베이스

  - 모든 데이터를 2차원 테이블 형태로 표현

  - 테이블은 서로 연관되어 있어 보다 효율적으로 데이터 저장, 구성 및 관리 가능

  - 정규화를 통해 데이터의 중복성을 최소화하며 트랜잭션을 수행하는 것이 더 쉽다.

  - 데이터의 원자성, 일관성, 격리 및 내구성을 유지하며 데이터 무결성을 높인다.

  - MSSQL, MySQL, Oracle 등

    

## Index란?

### 정의 및 설명

- 인덱스는 database 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료구조를 일컫는다.
- 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용해 생성될 수 있다.
- 고속의 검색 동작뿐 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
  - 레코드(record) : database의 row 또는 tuple로도 불린다.
- 인덱스 저장을 위한 디스크 공간 > 테이블 저장을 위한 디스크 공간
  - 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 가지고 있지 않기 때문.
- DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 추가, 삭제, 수정의 경우에는 쿼리문 실행 속도가 느려진다.
  - DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다.
- 관계형 데이터베이스(RDBMS)에서는 인덱스는 테이블 부분에 대한 하나의 사본.
- 인덱스는 고유 제약 조건을 실현하기 위해서도 사용.
  - 중복된 항목이 등록되는 것을 금지하기 때문에, 인덱스의 대상인 테이블에서 고유성이 보장됨.
- 인덱스로 설정하는 field의 속성의 중요하다. title, author 순서로 인덱스 설정한다면 title을 search할 경우, 효과를 볼 수 있지만, author만으로 search 할 경우, index를 생성한 것이 소용 없어진다. 즉, 인덱스 설정한 컬럼은 순서가 있다.

### Index 성능 및  고려사항

- 모든 컬럼에 INDEX를 생성해도 빨라지진 않는다.
- index 생성시, INSERT, DELETE, UPDATE는 느려진다. 
  - INSERT는 INDEX 컬럼을 생성해야 한다.
  -  DELETE및 SELECT의 경우 데이터를 삭제하지 않고 사용 안한다는 표시로 남게되어 row의 수는 그대로가 되기 때문이다.
- 컬럼의 range가 적으면 index를 만드는 것이 비효율적이다.
- 주로 primary key, foreign key, join할 record는 index가 있어야함.

### 기타

- Clustered Index : Primary Key 값이 비슷한 레코드끼리 묶어서 저장하는 것.
  - Primary key 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다.
  - 테이블 당 한개만 생성할 수 있다. Primary key만 적용되기 때문.

## 정규화

### 기초 용어

- 엔티티(Entity): 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체이다.
  - 사원번호, 사원이름, 과목코드가 들어있는 운영체제 같은 실체가 존재하는 객체 (사원번호, 이름 등도 엔티티가 될 수 있다.)
  - 프로젝트, 학과 등 추상적인 개념의 객체.
  - 엔티티는 엔티티 집합들로 분류된다.
- 엔티티 집합(Entity Set): 동일한 속성을 가진 엔티티의 집합.
  - 회사의 모든 사원들은 EMPLOYEE라는 엔티티 집합을 이룬다.
  - 엔티티 집합에 속한 요소들이 항상 서로 다르지는 않다.
  - 엔티티 타입이라고도 한다.
- 스키마(Schema): 데이터를 설명하는 데이터
  - 메타데이터라고도 한다.
  - 홍길동, 930830이라는 데이터는 이름, 생일이라는 스키마로 설명할 수 있다.
- attribute : (column, field) 

### 개념 및 목적

- 데이터의 중복을 줄이고 무결성을 향상시키는 등 여러 목적을 달성하기 위해 데이터 베이스를 정규화된 형태로 재디자인하는 것을 말함.
  - 무결성: 정확한 데이터를 가지고 있는 정도
- 불필요한 데이터를 제거, 중복 최소화
- database 구조 확장시 재디자인 최소화
- 다양한 관점에서의 query 지원을 위함
- 무결성 제약조건의 시행을 간단하게 하기 위함
- 각종 이상 현상 방지

### 정규화 대상

- CRUD가 많이 일어나는 프로그램 및 서비스
- 온라인 거래 시스템같은 OLTP

### 반정규화(denormalization)

- 정규화된 시스템을 성능 향상 및 개발과 운영의 단수노하를 위해 역으로 정규화를 수행하는 것.
- 일반적으로 join을 많이 사용해야 할 경우, 대량의 범위를 자주 처리하는 경우 등 조회에 대한 처리가 중요하다고 판단될 때 부분적으로 반정규화를 함.

##  Transaction

### 정의

- 작업의 완전성을 보장해주는 것이다.

- 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능.

- 또는 하나의 처리를 여러 단계로 나누는 기능

  - commit 명령어 수행하기 전 마지막으로 한 번 더 확인할 수 있는 기회를 줌으로써, 좀 더 안정적인 데이터베이스 작업을 가능하게 함.

  - ```mysql
    BEGIN TRAN -- 트랜잭션 시작
    ROLLBACK TRAN -- 트랜잭션 이전상태로 ROLL BACK
    COMMIT TRAN -- 트랜잭션 완료
    ```

- 사용자의 입장에선 작업의 논리적 단위로 이해.

- 시스템의 입장에선 데이터들을 접근 또는 변경하는 프로그램의 단위.

### Transaction과 Lock

- 잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 다름.
- Lock은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 함.
  - 커넥션 풀(Connection Pool) : DB와 미리 connection 해놓은 객체들을 pool(웅덩이)에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 볼일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말함.
  - 여기서 자원은 레코드나 테이블을 말함.
- Transaction은 하나의 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것.
  - 예를 들어, HW에러 또는 SW에러와 같은 문제로 인해 작업에 실패가 있을경우, 이러한 문제를 해결하는 것.

### 특성

- ACID라는 4가지 특성을 만족해야 함.
- 원자성(Atomicity) 
  - 만약 트랜잭션 중간에 어떤 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행해서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 함.
- 일관성(Consistency)
  - 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
- 고립성(Isolation)
  - 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
- 지속성(Durability)
  - 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

### 상태

![트랜잭션 상태 다이어그램](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/transaction-status.png)

- Active : 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작 중인 상태를 말한다.
- Failed : 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.
- Partially Committed : 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit 이전 sql 문이 수행되고 commit만 남은 상태를 말함.
- Committed : 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말함.
- Aborted : 트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말함.
- Partially Committed와 Committed의 차이점
  - Commit 요청이 들어오면 상태는 Partial committed 상태가 된다.
  - 이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 오류가 발생하면 Failed 상태가 된다.
  - 즉, Partial Committed는 Commit 요청이 들어왔을때를 말하며, Committed는 Commit을 정상적으로 완료한 상태를 말한다.

### 트랜잭션 사용 시 주의할 점

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. = 범위를 최소화해야 한다.
- 일반적으로 데이터베이스 커넥션은 갯수가 제한적이다.
- 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면, 사용 가능한 여유 커넥션의 개수는 줄어들게 된다.
- 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

## 교착 상태

### 정의

- 복수의 트랜잭션을 사용하다 보면 교착상태가 일어날 수 있다.
- 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태.

### 예시(MySQL)

![classic deadlock 출처: https://darkiri.wordpress.com/tag/sql-server/](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/deadlock.png)

트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 하자.

```mysql
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은채 서로의 첫번째 행에 대한 잠금을 요청하면

```mysql
Transaction 1> insert into A values(1); -- B 실행하던 트젝1이 A 실행
Transaction 2> insert into B values(1); -- A 실행하던 트젝2가 B 실행
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

데드락이 발생한다.

### 교착 상태의 빈도를 낮추는 법

- 트랜잭션을 자주 커밋한다.
- 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다.
  - 이 경우, 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

## NoSQL

### 사전 지식

- 수평적 확장 vs 수직적 확장
  - 수평 확장은 리소스 풀에 더 많은 시스템을 추가해 확장(분산 저장, NoSQL)
  - 수직 확장은 기존 시스템에 더 많은 전력(CPU, RAM)을 추가해 확장할 수 있음을 의미.(RDBMS)

### 정의

- 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 것에 특화되었으며, 스키마 없이 사용가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.
- 종류마다 쓰기 / 읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원 같은 고유한 특징을 가진다.
  - 샤딩(Sharding) 
    - RDBMS에서 대량의 데이터를 처리하기 위해 데이터를 파티셔닝하는 기술. 
    - DBMS level에서 데이터를 나누는 것이 아닌, 데이터베이스 자체를 분할하는 방식. 
    - 따라서 어플리케이션 레벨에서 구현해야 한다.
    - 예를 들어, 전 세계의 고객 데이터를 저장하는 대형 데이터베이스를 분산한다고 할 때, 미국 고객은 샤드A, 아시아 고객은 샤드B 형식으로 분할해서 저장할 수 있다.
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다.
- 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위해 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다.

### 특징

- 스키마가 없다. 즉, 데이터 관계가 정해진 규격(table - column의 정의)이 없다.
- 관계 정의가 없으니 JOIN이 불가능하다.(하지만 같은 기능으로 비슷하게 구현은 가능하다.)
- 트랜잭션을 지원하지 않는다.
- 분산처리(수평적 확장)를 쉽게 제공한다.

### 등장 배경

- 빅데이터 시대를 맞이해 서비스를 제공하는 시스템에서 많은 양의 데이터를 효율적으로 처리하는 것이 필요하게 되었다.
- 그 결과, 분산형 구조를 통해 데이터를 여러 대의 서버에 분산해 저장하고, 분산 시에 데이터를 상호 복제해 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조로 요구사항을 처리하게 되었다.

### 장점

- 정해진 스키마에 따라 저장해야 하는 RDBMS보다 자유롭게 데이터를 추가할 수 있다.
  - 자주 변경되지 않는 데이터로 인한 장점.
- 수평적 확장이 쉽다.(샤딩)
- 분산처리 목적으로 나왔기 때문에 프레임워크에서 분산처리 기능을 포함한다.

### 단점

- 자유롭게 데이터가 추가가 가능하기 때문에, 컬렉션에 중복된 데이터가 저장이 가능하다.